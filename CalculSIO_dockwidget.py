# -*- coding: utf-8 -*- 
"""
/***************************************************************************
 CalculSIODockWidget
                                 A QGIS plugin
 Calcul automatique des FU
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2023-06-14
        git sha              : $Format:%H$
        copyright            : (C) 2023 by Romain Lagrange - PCE Services
        email                : romain.lagrange@pceservices.fr
 ***************************************************************************/
/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
import os
from qgis.PyQt import QtGui, QtWidgets, uic
from qgis.PyQt.QtCore import pyqtSignal
from math import *
from qgis.PyQt import uic
from qgis.PyQt import QtWidgets
from operator import itemgetter
import itertools
from copy import deepcopy
import pandas as pd
import processing
from math import *
from PyQt5.QtCore import Qt
from qgis.PyQt import *
from qgis.core import *
from qgis.utils import iface
from PyQt5.QtWidgets import *
from PyQt5 import QtCore
from PyQt5.QtGui import * 
from PyQt5.QtCore import QVariant
from qgis.gui import QgsMapCanvas, QgsLayerTreeMapCanvasBridge
from qgis.PyQt.QtWidgets import QMessageBox
from qgis.gui import QgsMapToolEmitPoint
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'CalculSIO_dockwidget_base.ui'))
logs = ''
class CalculSIODockWidget(QtWidgets.QDockWidget, FORM_CLASS):
    closingPlugin = pyqtSignal()
    
    def __init__(self, parent=None):
        """Constructor."""
        super(CalculSIODockWidget, self).__init__(parent)
        # Set up the user interface from Designer.
        # After setupUI you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://doc.qt.io/qt-5/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)
    def closeEvent(self, event):
        self.closingPlugin.emit()
        event.accept()
    def calculBoite(self):
        global logs
        pointdedepart = self.sroLineEdit.text()
        for layer in QgsProject.instance().mapLayers().values():
            if 'boite_optique' in layer.name():
                boitelyr = layer
                boitelyr.removeSelection()
            if 'cable_optique' in layer.name():
                cablelyr = layer
                cablelyr.removeSelection()
            if 'ftth' in layer.name():
                ftthlyr = layer
                ftthlyr.removeSelection()
                ftthlyr.setSubsetString("statut!='ABANDONNE'")
            if 'ftte' in layer.name():
                fttelyr = layer
                fttelyr.removeSelection()
                fttelyr.setSubsetString("statut!='ABANDONNE'")
            if 'ftto' in layer.name():
                fttolyr = layer
                fttolyr.removeSelection()
                fttolyr.setSubsetString("statut!='ABANDONNE'")
            if 'zapbo' in layer.name():
                zapbolyr = layer
                zapbolyr.removeSelection()
                
            if 'zasro' in layer.name():
                zasrolyr = layer
                zasrolyr.removeSelection()
        if len(pointdedepart) == 19:
            sro = pointdedepart[4:14]
        if len(pointdedepart) == 14:
            sro = pointdedepart[4:]
        for boite in boitelyr.getFeatures():
            if sro in boite["nom"]:
                boitelyr.select(boite.id())
                
        for cable in cablelyr.getFeatures():
            if sro in cable["nom"]:
                cablelyr.select(cable.id())
                
        for zapbo in zapbolyr.getFeatures():
            if sro in zapbo["nom"]:
                zapbolyr.select(zapbo.id())
                
        for zasro in zasrolyr.getFeatures():
            if sro in zasro["ref_sro"]:
                zasrolyr.select(zasro.id())

        parameters = { 'INPUT' : ftthlyr,
            'INTERSECT' : QgsProcessingFeatureSourceDefinition(zasrolyr.dataProvider().dataSourceUri(), selectedFeaturesOnly=True, featureLimit=-1, geometryCheck=QgsFeatureRequest.GeometryAbortOnInvalid),
            'METHOD' : 0,
            'PREDICATE' : [6] }
        processing.run('qgis:selectbylocation', parameters)
        
        parameters = { 'INPUT' : fttelyr,
            'INTERSECT' : QgsProcessingFeatureSourceDefinition(zasrolyr.dataProvider().dataSourceUri(), selectedFeaturesOnly=True, featureLimit=-1, geometryCheck=QgsFeatureRequest.GeometryAbortOnInvalid),
            'METHOD' : 0,
            'PREDICATE' : [6] }
        processing.run('qgis:selectbylocation', parameters)
        
        parameters = { 'INPUT' : fttolyr,
            'INTERSECT' : QgsProcessingFeatureSourceDefinition(zasrolyr.dataProvider().dataSourceUri(), selectedFeaturesOnly=True, featureLimit=-1, geometryCheck=QgsFeatureRequest.GeometryAbortOnInvalid),
            'METHOD' : 0,
            'PREDICATE' : [6] }
        processing.run('qgis:selectbylocation', parameters)

        parameters = { 'INPUT' : ftthlyr,
            'INTERSECT' : QgsProcessingFeatureSourceDefinition(zapbolyr.dataProvider().dataSourceUri(), selectedFeaturesOnly=True, featureLimit=-1, geometryCheck=QgsFeatureRequest.GeometryAbortOnInvalid),
            'METHOD' : 2,
            'PREDICATE' : [2] }
        processing.run('qgis:selectbylocation', parameters)
        parameters = { 'INPUT' : fttelyr,
            'INTERSECT' : QgsProcessingFeatureSourceDefinition(zapbolyr.dataProvider().dataSourceUri(), selectedFeaturesOnly=True, featureLimit=-1, geometryCheck=QgsFeatureRequest.GeometryAbortOnInvalid),
            'METHOD' : 2,
            'PREDICATE' : [2] }
        processing.run('qgis:selectbylocation', parameters)
        parameters = { 'INPUT' : fttolyr,
            'INTERSECT' : QgsProcessingFeatureSourceDefinition(zapbolyr.dataProvider().dataSourceUri(), selectedFeaturesOnly=True, featureLimit=-1, geometryCheck=QgsFeatureRequest.GeometryAbortOnInvalid),
            'METHOD' : 2,
            'PREDICATE' : [2] }
        processing.run('qgis:selectbylocation', parameters)

        

        
        if ftthlyr.selectedFeatureCount() > 0:
            logs = logs+'• '+str(ftthlyr.selectedFeatureCount())+' ftth hors des zapbo\r\r\n'
        if fttelyr.selectedFeatureCount() > 0:
            logs = logs+'• '+str(fttelyr.selectedFeatureCount())+' ftte hors des zapbo\r\r\n'
        if fttolyr.selectedFeatureCount() > 0:
            logs = logs+'• '+str(fttolyr.selectedFeatureCount())+' ftto hors des zapbo\r\r\n'


        self.logsTextEdit.moveCursor(QtGui.QTextCursor.End)
        self.logsTextEdit.insertPlainText(logs)

        logs=''
        
        # Ajouter les champs ftth / ftte / ftto dans les zapbo et calculer la sommes des imb
        ftth_zapbo_field = QgsField('ftth', QVariant.Int)
        zapbolyr.addExpressionField("intersecting_geom_sum( 'ftth','nb_prise')", ftth_zapbo_field)
        ftte_zapbo_field = QgsField('ftte', QVariant.Int)
        zapbolyr.addExpressionField("intersecting_geom_sum( 'ftte','nb_prise')", ftte_zapbo_field)
        ftto_zapbo_field = QgsField('ftto', QVariant.Int)
        zapbolyr.addExpressionField("intersecting_geom_sum( 'ftto','nb_prise')", ftto_zapbo_field)

        # Intégrer les ftth / ftte / fafsh / fafse / nbfuh / nbfue aux boites optiques
        boitelyr.startEditing()
        ftth_boite_field = boitelyr.fields().indexFromName('ftth')
        fafsh_boite_field = boitelyr.fields().indexFromName('fafsh')
        nbfuh_boite_field = boitelyr.fields().indexFromName('nbfuh')
        for boite in boitelyr.selectedFeatures():
            if boite['fonction'] != 'PEC' and boite['fonction'] != 'BPE':
                for zapbo in zapbolyr.selectedFeatures():
                    if boite.geometry().intersects(zapbo.geometry()):
                        boitelyr.changeAttributeValue(boite.id(), ftth_boite_field, zapbo['ftth'])
                        boitelyr.changeAttributeValue(boite.id(), fafsh_boite_field, ceil(zapbo['ftth']*1.2))
                        boitelyr.changeAttributeValue(boite.id(), nbfuh_boite_field, ceil(ceil(zapbo['ftth']*1.2)/3)*3)
                        
            else:
                boitelyr.changeAttributeValue(boite.id(), ftth_boite_field, 0)
                boitelyr.changeAttributeValue(boite.id(), fafsh_boite_field, 0)
                boitelyr.changeAttributeValue(boite.id(), nbfuh_boite_field, 0)
                
                
        ftte_boite_field = boitelyr.fields().indexFromName('ftte')
        fafse_boite_field = boitelyr.fields().indexFromName('fafse')
        nbfue_boite_field = boitelyr.fields().indexFromName('nbfue')
        for boite in boitelyr.selectedFeatures():
            if boite['fonction'] != 'PEC' and boite['fonction'] != 'BPE':
                for zapbo in zapbolyr.selectedFeatures():
                    if boite.geometry().intersects(zapbo.geometry()):
                        boitelyr.changeAttributeValue(boite.id(), ftte_boite_field, zapbo['ftte']+zapbo['ftto'])
                        boitelyr.changeAttributeValue(boite.id(), fafse_boite_field, ceil(zapbo['ftte']*2+zapbo['ftto']*4))
                        boitelyr.changeAttributeValue(boite.id(), nbfue_boite_field, ceil(ceil(zapbo['ftte']*2+zapbo['ftto']*4)/3)*3)
            else:
                boitelyr.changeAttributeValue(boite.id(), ftte_boite_field, 0)
                boitelyr.changeAttributeValue(boite.id(), fafse_boite_field, 0)
                boitelyr.changeAttributeValue(boite.id(), nbfue_boite_field, 0)
        boitelyr.commitChanges()
        for boite in boitelyr.selectedFeatures():
            if boite['fonction'] != 'PEC' and boite['fonction'] != 'BPE':
                if boite['ftth'] == 0 and boite['ftte'] == 0:
                    self.logsTextEdit.moveCursor(QtGui.QTextCursor.End)
                    self.logsTextEdit.insertPlainText("• "+str(boite["nom"])+" hors zapbo ou 0 abonnés\r\r\n")

        
        

    def calculCable(self):
        pointdedepart = self.sroLineEdit.text()
        for layer in QgsProject.instance().mapLayers().values():
            if 'boite_optique' in layer.name():
                boitelyr = layer
                boitelyr.removeSelection()
            if 'cable_optique' in layer.name():
                cablelyr = layer
                cablelyr.removeSelection()

        if len(pointdedepart) == 19:
            sro = pointdedepart[4:14]
        if len(pointdedepart) == 14:
            sro = pointdedepart[4:]
        for boite in boitelyr.getFeatures():
            if sro in boite["nom"]:
                boitelyr.select(boite.id())
                
        for cable in cablelyr.getFeatures():
            if sro in cable["nom"]:
                cablelyr.select(cable.id())
                
        syno = []
        #récupérer le tracé de toutes les boites extremités
        for boite in boitelyr.selectedFeatures():
            if sro in boite['nom']:
                tabtemp = []
                boiteactuelle = boite["nom"]
                origine = 0
                for cable in cablelyr.selectedFeatures():
                    if boiteactuelle == cable["origine"]:
                        origine = 1
                if origine ==0:
                    tabtemp.append(boiteactuelle)
                x = 0
                while (boiteactuelle != pointdedepart and origine == 0):
                    for cable in cablelyr.selectedFeatures():
                        if sro in cable['nom']:
                            if cable["extremite"] == boiteactuelle and boiteactuelle != pointdedepart:
                                boiteactuelle = cable["origine"]
                                tabtemp.append(boiteactuelle)
                                x=0
                    x+=1
                    if x > 2:
                        break
                tabtemp.reverse()
                if tabtemp:
                    syno.append(tabtemp)
        templist = syno
        syno = []
        for index,ligne in enumerate(templist):
            if ligne[0] == pointdedepart:
                syno.append(templist[index])
        flat_list = [item for sublist in syno for item in sublist]
        listeerreur = []
        for boite in boitelyr.selectedFeatures():
            if boite['nom'] not in flat_list and sro in boite['nom']:
                listeerreur.append(boite['nom'])
        
        if listeerreur != []:
            self.logsTextEdit.moveCursor(QtGui.QTextCursor.End)
            self.logsTextEdit.insertPlainText('Pas de continuité entre '+pointdedepart+' et les boites suivantes : \r\n • '+str(listeerreur)[2:-2].replace("', '","\r\n • ")+"\r\r\n")

        #compter le nb d'évenement maximum et compléter chaque ligne pour avoir le même nombre de valeur
        nbevenement= []
        for ligne in syno:
            nbevenement.append(len(ligne))
        maxevenement = max(nbevenement)
        for indexligne, ligne in enumerate(syno):
            if len(ligne) < maxevenement:
                while len(ligne) < maxevenement:
                    syno[indexligne].append('')
        #Trier le tableau en partant de la derniere colonne et remonter jusqu'à la premiere
        maxevenement-=1
        while maxevenement != 0:
            syno = sorted(syno, key=itemgetter(maxevenement))
            maxevenement-=1
        roptemp = deepcopy(syno)
        roptempftte = deepcopy(syno)
        #Remplacer toute les valeurs en double par des valeurs vides
        templist = []
        for indexligne, ligne in  enumerate(syno):
            for indexvaleur, valeur in enumerate(ligne):
                if valeur in templist:
                        syno[indexligne][indexvaleur] = ''
                else:
                    templist.append(valeur)
        tableaupourrop = deepcopy(syno)
        for indexligne, ligne in enumerate(tableaupourrop):
            for indexboite, boite in enumerate(ligne):
                if boite != '':
                    for feature in boitelyr.selectedFeatures():
                        if feature["nom"] == boite:
                            tableaupourrop[indexligne][indexboite] = [feature["nom"],feature["ftth"],feature["nbfue"]]
        tableaupourrop.reverse()
        for indexligne, ligne in enumerate(tableaupourrop):
            i = len(ligne)-1
            nbabonnes = 0
            nbfutile = 0
            while i >= 0:
                if ligne[i] != '' and ligne[i] != pointdedepart:

                    nbabonnes = nbabonnes+ligne[i][1]
                    nbfutile = nbfutile+ligne[i][2]
                    ligne[i] = [ligne[i][0],nbabonnes,nbfutile]
                    if ligne[i-1] == '' and i-1 != 0:
                        for cable in cablelyr.selectedFeatures():
                            if cable["extremite"] == ligne[i][0]:
                                for indexligne2, ligne2 in enumerate(tableaupourrop):
                                    for indexensemble2,ensemble2 in enumerate(ligne2):
                                        if ensemble2 != '' and ensemble2 != pointdedepart:
                                            if ensemble2[0] == cable["origine"]:
                                                tableaupourrop[indexligne2][indexensemble2][1] = tableaupourrop[indexligne2][indexensemble2][1] + ligne[i][1]
                                                tableaupourrop[indexligne2][indexensemble2][2] = tableaupourrop[indexligne2][indexensemble2][2] + ligne[i][2]
                i-=1
        tableaupourrop.reverse()
        cablelyr.startEditing()
        fuefield = cablelyr.fields().indexOf('fue')
        for ligne in tableaupourrop:
            for boite in ligne:
                if len(boite) == 3 :
                    for cable in cablelyr.selectedFeatures():
                        if cable["extremite"] == boite[0]:
                            cablelyr.changeAttributeValue(cable.id(), fuefield, boite[2])
                            
                            
        #FUH

        #récupérer le tracé de toutes les boites extremités
        for boite in boitelyr.selectedFeatures():
            if sro in boite['nom']:
                tabtemp = []
                boiteactuelle = boite["nom"]
                origine = 0
                for cable in cablelyr.selectedFeatures():
                    if boiteactuelle == cable["origine"]:
                        origine = 1
                if origine ==0:
                    tabtemp.append(boiteactuelle)
                x = 0
                while (boiteactuelle != pointdedepart and origine == 0):
                    for cable in cablelyr.selectedFeatures():
                        if sro in cable['nom']:
                            if cable["extremite"] == boiteactuelle and boiteactuelle != pointdedepart:
                                boiteactuelle = cable["origine"]
                                tabtemp.append(boiteactuelle)
                                x=0
                    x+=1
                    if x > 2:
                        break
                tabtemp.reverse()
                if tabtemp:
                    syno.append(tabtemp)
        templist = syno
        syno = []
        for index,ligne in enumerate(templist):
            if ligne[0] == pointdedepart:
                syno.append(templist[index])
        flat_list = [item for sublist in syno for item in sublist]
        listeerreur = []
        for boite in boitelyr.selectedFeatures():
            if boite['nom'] not in flat_list and sro in boite['nom']:
                listeerreur.append(boite['nom'])

        #compter le nb d'évenement maximum et compléter chaque ligne pour avoir le même nombre de valeur
        nbevenement= []
        for ligne in syno:
            nbevenement.append(len(ligne))
        maxevenement = max(nbevenement)
        for indexligne, ligne in enumerate(syno):
            if len(ligne) < maxevenement:
                while len(ligne) < maxevenement:
                    syno[indexligne].append('')
        #Trier le tableau en partant de la derniere colonne et remonter jusqu'à la premiere
        maxevenement-=1
        while maxevenement != 0:
            syno = sorted(syno, key=itemgetter(maxevenement))
            maxevenement-=1
        roptemp = deepcopy(syno)
        roptempftte = deepcopy(syno)
        #Remplacer toute les valeurs en double par des valeurs vides
        templist = []
        for indexligne, ligne in  enumerate(syno):
            for indexvaleur, valeur in enumerate(ligne):
                if valeur in templist:
                        syno[indexligne][indexvaleur] = ''
                else:
                    templist.append(valeur)
        tableaupourrop = deepcopy(syno)
        for indexligne, ligne in enumerate(tableaupourrop):
            for indexboite, boite in enumerate(ligne):
                if boite != '':
                    for feature in boitelyr.selectedFeatures():
                        if feature["nom"] == boite:
                            tableaupourrop[indexligne][indexboite] = [feature["nom"],feature["ftth"],feature["nbfuh"]]
        tableaupourrop.reverse()
        for indexligne, ligne in enumerate(tableaupourrop):
            i = len(ligne)-1
            nbabonnes = 0
            nbfutile = 0
            while i >= 0:
                if ligne[i] != '' and ligne[i] != pointdedepart:
                    nbabonnes = nbabonnes+ligne[i][1]
                    nbfutile = nbfutile+ligne[i][2]
                    ligne[i] = [ligne[i][0],nbabonnes,nbfutile]
                    if ligne[i-1] == '' and i-1 != 0:
                        for cable in cablelyr.selectedFeatures():
                            if cable["extremite"] == ligne[i][0]:
                                for indexligne2, ligne2 in enumerate(tableaupourrop):
                                    for indexensemble2,ensemble2 in enumerate(ligne2):
                                        if ensemble2 != '' and ensemble2 != pointdedepart:
                                            if ensemble2[0] == cable["origine"]:
                                                tableaupourrop[indexligne2][indexensemble2][1] = tableaupourrop[indexligne2][indexensemble2][1] + ligne[i][1]
                                                tableaupourrop[indexligne2][indexensemble2][2] = tableaupourrop[indexligne2][indexensemble2][2] + ligne[i][2]
                i-=1
        tableaupourrop.reverse()
        cablelyr.startEditing()
        fuhfield = cablelyr.fields().indexOf('fuh')
        for ligne in tableaupourrop:
            for boite in ligne:
                if len(boite) == 3 :
                    for cable in cablelyr.selectedFeatures():
                        if cable["extremite"] == boite[0]:
                            cablelyr.changeAttributeValue(cable.id(), fuhfield, boite[2])
        tuhfield = cablelyr.fields().indexOf('tuh')
        tuefield = cablelyr.fields().indexOf('tue')
        for cable in cablelyr.selectedFeatures():
            if cable['fuh'] != '' and cable['fuh'] != NULL :
                cablelyr.changeAttributeValue(cable.id(), tuhfield, cable['fuh']/12)
            if cable['fue'] != '' and cable['fue'] != NULL :
                cablelyr.changeAttributeValue(cable.id(), tuefield, cable['fue']/12)
        cablelyr.commitChanges()
    def copierLogs(self):
        self.logsTextEdit.selectAll()
        self.logsTextEdit.copy()
    def supprimerLogs(self):
        self.logsTextEdit.clear()